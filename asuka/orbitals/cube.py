from __future__ import annotations

from typing import Any

import numpy as np

from asuka.frontend.molecule import Molecule
from asuka.frontend.periodic_table import atomic_number
from asuka.integrals.cart2sph import AOSphericalTransform

from .eval_cart import CubeGrid, eval_mos_cart_on_points, make_cube_grid_from_atoms


def _atom_coords_bohr(mol: Molecule) -> np.ndarray:
    return np.asarray(mol.coords_bohr, dtype=np.float64).reshape((mol.natm, 3))


def write_cube_header(
    f,
    mol: Molecule,
    grid: CubeGrid,
    *,
    comment1: str = "ASUKA cube",
    comment2: str = "generated by asuka.orbitals",
) -> None:
    """Write Gaussian cube header. Units: Bohr (ASUKA internal)."""

    f.write(f"{comment1}\n")
    f.write(f"{comment2}\n")

    origin = np.asarray(grid.origin, dtype=np.float64).reshape((3,))
    nx, ny, nz = map(int, grid.shape)
    axes = np.asarray(grid.axes, dtype=np.float64).reshape((3, 3))

    f.write(f"{mol.natm:5d} {origin[0]:12.6f} {origin[1]:12.6f} {origin[2]:12.6f}\n")
    f.write(f"{nx:5d} {axes[0,0]:12.6f} {axes[0,1]:12.6f} {axes[0,2]:12.6f}\n")
    f.write(f"{ny:5d} {axes[1,0]:12.6f} {axes[1,1]:12.6f} {axes[1,2]:12.6f}\n")
    f.write(f"{nz:5d} {axes[2,0]:12.6f} {axes[2,1]:12.6f} {axes[2,2]:12.6f}\n")

    coords = _atom_coords_bohr(mol)
    for i in range(mol.natm):
        sym = mol.atom_symbol(i)
        Z = int(atomic_number(sym))
        x, y, z = coords[i]
        f.write(f"{Z:5d} {float(Z):12.6f} {x:12.6f} {y:12.6f} {z:12.6f}\n")


def write_mo_cube(
    path: str,
    mol: Molecule,
    ao_basis: Any,
    C: Any,
    mo: int,
    *,
    grid: CubeGrid | None = None,
    spacing: float = 0.25,
    padding: float = 4.0,
    values_per_line: int = 6,
    sph_map: AOSphericalTransform | tuple[np.ndarray, int, int] | None = None,
) -> None:
    """Write a cube file for one (real) MO."""

    mo = int(mo)
    if grid is None:
        grid = make_cube_grid_from_atoms(_atom_coords_bohr(mol), spacing=float(spacing), padding=float(padding))

    nx, ny, nz = map(int, grid.shape)
    origin = np.asarray(grid.origin, dtype=np.float64).reshape((3,))
    axes = np.asarray(grid.axes, dtype=np.float64).reshape((3, 3))

    # Indices for an xy-slice (flattened). Supports general axis vectors.
    ix = np.arange(nx, dtype=np.float64)
    iy = np.arange(ny, dtype=np.float64)
    ixf, iyf = np.meshgrid(ix, iy, indexing="ij")
    ixf = ixf.reshape((-1, 1))
    iyf = iyf.reshape((-1, 1))
    axis0 = axes[0].reshape((1, 3))
    axis1 = axes[1].reshape((1, 3))
    axis2 = axes[2].reshape((1, 3))

    npl = int(values_per_line)
    if npl <= 0:
        raise ValueError("values_per_line must be > 0")

    with open(path, "w", encoding="utf-8") as f:
        write_cube_header(f, mol, grid, comment1="ASUKA MO cube", comment2=f"MO {mo}")

        for kz in range(nz):
            base = origin[None, :] + float(kz) * axis2
            pts = base + ixf * axis0 + iyf * axis1  # (nx*ny,3)

            psi = eval_mos_cart_on_points(ao_basis, C, pts, [mo], sph_map=sph_map)[:, 0]  # (nx*ny,)

            for i, val in enumerate(psi.tolist()):
                f.write(f"{val:13.5e}")
                if (i + 1) % npl == 0:
                    f.write("\n")
            if (nx * ny) % npl != 0:
                f.write("\n")


__all__ = ["write_cube_header", "write_mo_cube"]
